{"version":3,"sources":["../src/elektrik/quote.ts","../src/chains.ts","../src/elektrik/swap.ts","../src/token/permit2.ts","../src/token/approval.ts","../src/weth/wrap.ts","../src/weth/unwrap.ts","../src/explorer/search.ts","../src/explorer/contract.ts","../src/ens.ts","../src/token/info.ts","../src/token/balance.ts","../src/index.ts"],"sourcesContent":["import {\n  decodeFunctionResult,\n  encodeFunctionData,\n  type Abi,\n  type Address,\n  type PublicClient,\n} from \"viem\";\nimport { getSupportedPublicClient, Pegasus, Phoenix } from \"../chains.js\";\n\nconst QuoterABI: Abi = [\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n          { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n          { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n          {\n            internalType: \"uint160\",\n            name: \"sqrtPriceLimitX96\",\n            type: \"uint160\",\n          },\n        ],\n        internalType: \"struct IQuoterV2.QuoteExactInputSingleParams\",\n        name: \"params\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"quoteExactInputSingle\",\n    outputs: [\n      { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n      {\n        internalType: \"uint160\",\n        name: \"sqrtPriceX96After\",\n        type: \"uint160\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"initializedTicksCrossed\",\n        type: \"uint32\",\n      },\n      { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n] as const;\n\nexport interface QuoteExactInputSingleParams {\n  fromToken: `0x${string}`;\n  toToken: `0x${string}`;\n  amountIn: bigint;\n  fee: number;\n}\n\nexport interface QuoteResult {\n  amountOut: bigint;\n  sqrtPriceX96After: bigint;\n  initializedTicksCrossed: bigint;\n  gasEstimate: bigint;\n}\n\nexport const quoteExactInput = async (\n  chainId: number,\n  params: QuoteExactInputSingleParams\n): Promise<QuoteResult> => {\n  const client = getSupportedPublicClient(chainId);\n  const quoterContractAddress =\n    chainId == Phoenix.id ? Phoenix.elektrik.quoter : Pegasus.elektrik.quoter;\n\n  return _quoteExactInput(client, quoterContractAddress as Address, params);\n};\n\nconst _quoteExactInput = async (\n  client: PublicClient,\n  quoterContractAddress: `0x${string}`,\n  params: QuoteExactInputSingleParams\n) => {\n  const { fromToken, toToken, amountIn, fee } = params;\n  // Prepare the call\n  const encodedData = encodeFunctionData({\n    abi: QuoterABI,\n    functionName: \"quoteExactInputSingle\",\n    args: [\n      {\n        tokenIn: fromToken,\n        tokenOut: toToken,\n        amountIn: amountIn,\n        fee: fee,\n        sqrtPriceLimitX96: 0n, // no limit\n      },\n    ],\n  });\n\n  // Perform the static call\n  const response = await client.call({\n    to: quoterContractAddress,\n    data: encodedData,\n  });\n\n  // Decode the response\n  const result = decodeFunctionResult({\n    abi: QuoterABI,\n    functionName: \"quoteExactInputSingle\",\n    data: response.data!,\n  }) as [bigint, bigint, bigint, bigint];\n\n  // Extract the individual outputs\n  const quotedAmountOut = result[0];\n  const sqrtPriceX96After = result[1];\n  const initializedTicksCrossed = result[2];\n  const gasEstimate = result[3];\n\n  return {\n    amountOut: quotedAmountOut,\n    sqrtPriceX96After,\n    initializedTicksCrossed,\n    gasEstimate,\n  } as QuoteResult;\n};\n","import { createPublicClient, defineChain, http } from \"viem\";\nimport { lightlinkPegasus, lightlinkPhoenix } from \"viem/chains\";\n\nconst CONTRACTS = {\n  lightlink: {\n    UNIVERSAL_ROUTER: \"0x6B3ea22C757BbF9C78CcAaa2eD9562b57001720B\",\n    UNISWAP_V3_FACTORY_ADDRESS: \"0xEE6099234bbdC793a43676D98Eb6B589ca7112D7\",\n    UNISWAP_V3_QUOTER_ADDRESS: \"0x243551e321Dac40508c22de2E00aBECF17F764b5\",\n  },\n\n  lightlinkTestnet: {\n    UNIVERSAL_ROUTER: \"0x742d315e929B188e3F05FbC49774474a627b0502\",\n    UNISWAP_V3_FACTORY_ADDRESS: \"0x7A5531FC6628e55f22ED2C6AD015B75948fC36F4\",\n    UNISWAP_V3_QUOTER_ADDRESS: \"0x97e7D916aa065eADA70B317677fb8a4A5504F51f\",\n  },\n};\n\ninterface Network {\n  id: number;\n  name: string;\n  rpcUrl: string;\n  explorerUrl: string;\n  elektrik: {\n    quoter: string;\n    router: string;\n    factory: string;\n  };\n  ens?: { resolver: string };\n  permit2: string;\n  weth: string;\n}\n\nexport const Phoenix: Network = {\n  id: 1890,\n  name: \"Lightlink Phoenix\",\n  rpcUrl: process.env.LIGHTLINK_MAINNET_RPC_URL || \"\",\n  explorerUrl: \"https://phoenix.lightlink.io\",\n  elektrik: {\n    quoter: CONTRACTS.lightlink.UNISWAP_V3_QUOTER_ADDRESS,\n    router: CONTRACTS.lightlink.UNIVERSAL_ROUTER,\n    factory: CONTRACTS.lightlink.UNISWAP_V3_FACTORY_ADDRESS,\n  },\n  permit2: \"0xB952578f3520EE8Ea45b7914994dcf4702cEe578\",\n  weth: \"0x7EbeF2A4b1B09381Ec5B9dF8C5c6f2dBECA59c73\",\n};\n\nexport const Pegasus: Network = {\n  id: 1891,\n  name: \"Lightlink Pegasus\",\n  rpcUrl: process.env.LIGHTLINK_TESTNET_RPC_URL || \"\",\n  explorerUrl: \"https://pegasus.lightlink.io\",\n  elektrik: {\n    quoter: CONTRACTS.lightlinkTestnet.UNISWAP_V3_QUOTER_ADDRESS,\n    router: CONTRACTS.lightlinkTestnet.UNIVERSAL_ROUTER,\n    factory: CONTRACTS.lightlinkTestnet.UNISWAP_V3_FACTORY_ADDRESS,\n  },\n  permit2: \"0x65b0dE86Df48d72aCdaF7E548b5C836663A0a4fa\",\n  weth: \"0xF42991f02C07AB66cFEa282E7E482382aEB85461\",\n};\n\nexport const getSupportedPublicClient = (id: number) => {\n  if (id != Phoenix.id && id != Pegasus.id) {\n    throw new Error(\"Unsupported chain\");\n  }\n\n  const chain = id == Phoenix.id ? lightlinkPhoenix : lightlinkPegasus;\n\n  return createPublicClient({\n    chain: chain,\n    transport: http(),\n  });\n};\n","import {\n  encodeAbiParameters,\n  encodeFunctionData,\n  encodePacked,\n  type Abi,\n  type PublicClient,\n  type WalletClient,\n} from \"viem\";\nimport { getSupportedPublicClient, Pegasus, Phoenix } from \"../chains.js\";\nimport { ensurePermit2Allowance } from \"../token/permit2.js\";\nimport type { PreparedTx } from \"../common.js\";\n\nexport interface SwapExactInputParams {\n  tokenIn: `0x${string}`;\n  tokenOut: `0x${string}`;\n  amountIn: bigint;\n  amountOut: bigint;\n  fee: number;\n  slippage: number;\n}\n\nexport interface SwapExactInputResult {\n  txHash: `0x${string}`;\n  minAmountOut: bigint;\n}\n\nconst SWAP_EXACT_IN = \"0x00\";\n\nconst UniversalRouterABI: Abi = [\n  {\n    inputs: [\n      { internalType: \"bytes\", name: \"commands\", type: \"bytes\" },\n      { internalType: \"bytes[]\", name: \"inputs\", type: \"bytes[]\" },\n    ],\n    name: \"execute\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n] as const;\n\nexport const prepareSwapExactInput = async (\n  chainId: number,\n  sender: `0x${string}`,\n  params: SwapExactInputParams\n) => {\n  if (params.slippage < 0 || params.slippage > 1)\n    throw new Error(\"Slippage must be between 0 and 1\");\n\n  const txs: PreparedTx[] = [];\n\n  const universalRouterAddress =\n    chainId == Phoenix.id\n      ? (Phoenix.elektrik.router as `0x${string}`)\n      : (Pegasus.elektrik.router as `0x${string}`);\n\n  // Step 1. Ensure Permit2 is approved\n  txs.push(\n    ...(await ensurePermit2Allowance(\n      chainId,\n      params.tokenIn,\n      sender,\n      universalRouterAddress,\n      params.amountIn + BigInt(1)\n    ))\n  );\n\n  // Step 2. Calculate minimum amount out\n  const slippageBP = BigInt(Math.floor(params.slippage * 10000));\n  const minAmountOut =\n    params.amountOut - (params.amountOut * slippageBP) / 10000n;\n\n  // Step 3. encode the swap route\n  const route = encodePacked(\n    [\"address\", \"uint24\", \"address\"],\n    [params.tokenIn, params.fee, params.tokenOut]\n  );\n\n  // step 4. encode the inputs for V3_SWAP_EXACT_IN\n  const inputs = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes\" },\n      { type: \"bool\" },\n    ],\n    [sender, params.amountIn, minAmountOut, route, true]\n  );\n\n  const data = encodeFunctionData({\n    functionName: \"execute\",\n    abi: UniversalRouterABI,\n    args: [SWAP_EXACT_IN, [inputs]],\n  });\n\n  // step 5. execute the swap\n  txs.push({\n    to: universalRouterAddress,\n    data,\n    description: \"Executing swap via Universal Router\",\n  });\n\n  return txs;\n};\n","import { encodeFunctionData, type Abi } from \"viem\";\nimport type { PreparedTx } from \"../common.js\";\nimport { getSupportedPublicClient, Pegasus, Phoenix } from \"../chains.js\";\nimport { ensureAllowance } from \"./approval.js\";\n\nconst Permit2ABI: Abi = [\n  {\n    name: \"allowance\",\n    type: \"function\",\n    inputs: [\n      { type: \"address\", name: \"owner\" },\n      { type: \"address\", name: \"token\" },\n      { type: \"address\", name: \"spender\" },\n    ],\n    outputs: [{ type: \"uint256\", name: \"allowance\" }],\n    stateMutability: \"view\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"token\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint160\", name: \"amount\", type: \"uint160\" },\n      { internalType: \"uint48\", name: \"expiration\", type: \"uint48\" },\n    ],\n    name: \"approve\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n] as const;\n\nexport function preparePermit2ApprovalTx(\n  chainId: number,\n  token: `0x${string}`,\n  target: `0x${string}`,\n  amount: bigint,\n  deadline: number\n): PreparedTx {\n  const permit2 =\n    chainId == Phoenix.id\n      ? (Phoenix.permit2 as `0x${string}`)\n      : (Pegasus.permit2 as `0x${string}`);\n\n  return {\n    to: permit2,\n    data: encodeFunctionData({\n      abi: Permit2ABI,\n      functionName: \"approve\",\n      args: [token, target, amount, deadline],\n    }),\n    description: \"Using Permit2 to approve the target to spend the token\",\n  };\n}\n\nexport async function fetchPermit2Allowance(\n  chainId: number,\n  owner: `0x${string}`,\n  token: `0x${string}`,\n  spender: `0x${string}`\n) {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  const permit2 =\n    chainId == Phoenix.id\n      ? (Phoenix.permit2 as `0x${string}`)\n      : (Pegasus.permit2 as `0x${string}`);\n\n  return (await publicClient.readContract({\n    address: permit2,\n    abi: Permit2ABI,\n    functionName: \"allowance\",\n    args: [owner, token, spender],\n  })) as bigint;\n}\n\nconst ONE_DAY_IN_SECONDS = 86400;\n\nexport async function ensurePermit2Allowance(\n  chainId: number,\n  token: `0x${string}`,\n  owner: `0x${string}`,\n  spender: `0x${string}`,\n  amount: bigint\n) {\n  const txs: PreparedTx[] = [];\n\n  const permit2 =\n    chainId == Phoenix.id\n      ? (Phoenix.permit2 as `0x${string}`)\n      : (Pegasus.permit2 as `0x${string}`);\n\n  // Step 1. Ensure Permit2 has\n  txs.push(...(await ensureAllowance(chainId, token, owner, permit2, amount)));\n\n  // Step 2. Check if target is approved on Permit2\n  const allowance = await fetchPermit2Allowance(chainId, owner, token, spender);\n  if (allowance >= amount) {\n    return txs;\n  }\n\n  // Step 3. Approve Permit2 on target\n  const deadline = Math.floor(Date.now() / 1000) + ONE_DAY_IN_SECONDS;\n  txs.push(preparePermit2ApprovalTx(chainId, token, spender, amount, deadline));\n\n  return txs;\n}\n","import { encodeFunctionData, type Abi } from \"viem\";\nimport type { PreparedTx } from \"../common.js\";\nimport { getSupportedPublicClient } from \"../chains.js\";\n\nconst TokenABI: Abi = [\n  {\n    name: \"approve\",\n    type: \"function\",\n    inputs: [\n      { type: \"address\", name: \"spender\" },\n      { type: \"uint256\", name: \"amount\" },\n    ],\n    outputs: [{ type: \"bool\", name: \"success\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    name: \"allowance\",\n    type: \"function\",\n    inputs: [\n      { type: \"address\", name: \"owner\" },\n      { type: \"address\", name: \"spender\" },\n    ],\n    outputs: [{ type: \"uint256\", name: \"allowance\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\nexport function prepareApprovalTx(\n  token: `0x${string}`,\n  target: `0x${string}`,\n  amount: bigint\n): PreparedTx {\n  return {\n    to: token,\n    data: encodeFunctionData({\n      abi: TokenABI,\n      functionName: \"approve\",\n      args: [target, amount],\n    }),\n    description: \"Approving token to be spent by target\",\n  };\n}\n\nexport async function fetchAllowance(\n  chainId: number,\n  token: `0x${string}`,\n  owner: `0x${string}`,\n  spender: `0x${string}`\n) {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  return (await publicClient.readContract({\n    address: token,\n    abi: TokenABI,\n    functionName: \"allowance\",\n    args: [owner, spender],\n  })) as bigint;\n}\n\nexport async function ensureAllowance(\n  chainId: number,\n  token: `0x${string}`,\n  owner: `0x${string}`,\n  spender: `0x${string}`,\n  amount: bigint\n) {\n  const txs: PreparedTx[] = [];\n\n  const allowance = await fetchAllowance(chainId, token, owner, spender);\n  if (allowance < amount) {\n    txs.push(prepareApprovalTx(token, spender, amount));\n  }\n\n  return txs;\n}\n","import type { Abi, Address } from \"viem\";\nimport { withdraw } from \"viem/zksync\";\nimport { getSupportedPublicClient, Pegasus, Phoenix } from \"../chains.js\";\nimport type { PreparedTx } from \"../common.js\";\n\nconst WethABI: Abi = [\n  // function deposit() public payable\n  {\n    name: \"deposit\",\n    inputs: [],\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n] as const;\n\nexport const prepareWrapTx = (chainId: number, amount: bigint): PreparedTx => {\n  const wethAddress =\n    chainId == Phoenix.id\n      ? (Phoenix.weth as `0x${string}`)\n      : (Pegasus.weth as `0x${string}`);\n\n  return {\n    to: wethAddress,\n    data: \"0x\",\n    value: amount,\n    description: \"Wrapping ETH\",\n  };\n};\n","import { encodeFunctionData, type Abi } from \"viem\";\nimport { Pegasus, Phoenix } from \"../chains.js\";\nimport type { PreparedTx } from \"../common.js\";\n\nconst WETH_ABI: Abi = [\n  // function withdraw(uint wad) public\n  {\n    name: \"withdraw\",\n    inputs: [{ name: \"wad\", type: \"uint256\" }],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n] as const;\n\nexport const prepareUnwrapTx = (\n  chainId: number,\n  amount: bigint\n): PreparedTx => {\n  const wethAddress =\n    chainId == Phoenix.id\n      ? (Phoenix.weth as `0x${string}`)\n      : (Pegasus.weth as `0x${string}`);\n\n  return {\n    to: wethAddress,\n    data: encodeFunctionData({\n      abi: WETH_ABI,\n      functionName: \"withdraw\",\n      args: [amount],\n    }),\n    description: \"Unwrapping WETH\",\n  };\n};\n","import { lightlinkPegasus, lightlinkPhoenix } from \"viem/chains\";\n\nexport interface EnsProtocol {\n  deployment_blockscout_base_url: string;\n  description: string;\n  docs_url: string;\n  icon_url: string;\n  id: string;\n  short_name: string;\n  title: string;\n  tld_list: string[];\n}\n\nexport interface EnsInfo {\n  name: string;\n  protocol: EnsProtocol;\n  address_hash: string;\n  expiry_date: string;\n  names_count: number;\n}\n\nexport interface BaseItem {\n  address: string;\n  certified: boolean;\n  is_smart_contract_verified: boolean;\n  name: string | null;\n  priority: number;\n  type: string;\n  url: string;\n}\n\nexport interface EnsDomainItem extends BaseItem {\n  type: \"ens_domain\";\n  ens_info: EnsInfo;\n}\n\nexport interface ContractItem extends BaseItem {\n  type: \"contract\";\n  ens_info: null;\n}\n\nexport interface AddressItem extends BaseItem {\n  type: \"address\";\n  ens_info: null;\n}\n\nexport interface TokenItem extends BaseItem {\n  type: \"token\";\n  address_url: string;\n  circulating_market_cap: number | null;\n  exchange_rate: number | null;\n  icon_url: string;\n  is_verified_via_admin_panel: boolean;\n  symbol: string;\n  token_type: string;\n  token_url: string;\n  total_supply: string;\n}\n\nexport type SearchItem = EnsDomainItem | ContractItem | AddressItem | TokenItem;\n\nexport const search = async (\n  chainId: number,\n  query: string\n): Promise<SearchItem[]> => {\n  if (chainId !== lightlinkPegasus.id && chainId !== lightlinkPhoenix.id)\n    throw new Error(\"Unsupported chain\");\n\n  const explorer =\n    chainId === lightlinkPegasus.id\n      ? lightlinkPegasus.blockExplorers.default.url\n      : lightlinkPhoenix.blockExplorers.default.url;\n  const apiUrl = explorer + \"/api/v2/\";\n  const response = await fetch(apiUrl + \"search?q=\" + query);\n  const data = (await response.json()) as any;\n\n  return data.items as SearchItem[];\n};\n","import type { Abi } from \"viem\";\nimport { lightlinkPegasus, lightlinkPhoenix } from \"viem/chains\";\n\nexport interface BaseContract {\n  is_verified?: boolean;\n  creation_bytecode: string;\n  deployed_bytecode: string;\n  has_custom_methods_read: boolean;\n  has_custom_methods_write: boolean;\n  implementations: any[];\n  is_self_destructed: boolean;\n  proxy_type: string;\n}\n\nexport interface UnverifiedContract extends BaseContract {\n  is_verified: undefined;\n}\n\nexport interface AdditionalSource {\n  file_path: string;\n  source_code: string;\n}\n\nexport interface VerifiedContract extends BaseContract {\n  is_verified: true;\n  name: string;\n  is_blueprint: boolean;\n  license_type: string;\n  is_fully_verified: boolean;\n  is_vyper_contract: boolean;\n  is_verified_via_eth_bytecode_db: boolean;\n  language: string;\n  evm_version: string;\n  file_path: string;\n  source_code: string;\n  optimization_enabled: boolean;\n  verified_twin_address_hash: string;\n  compiler_settings: {\n    libraries: any;\n    optimizer: {\n      enabled: boolean;\n      runs: number;\n    };\n    outputSelection: {\n      [key: string]: string[];\n    };\n  };\n  optimization_runs: number;\n  sourcify_repo_url: string;\n  decoded_constructor_args: any[];\n  compiler_version: string;\n  is_verified_via_verifier_alliance: boolean;\n  verified_at: string;\n  external_libraries: any[];\n  additional_sources: AdditionalSource[];\n  abi: Abi;\n  is_changed_bytecode: boolean;\n  is_partially_verified: boolean;\n  constructor_args: string;\n}\n\nexport type Contract = UnverifiedContract | VerifiedContract;\n\nexport const getContractInfo = async (chainId: number, address: string) => {\n  if (chainId !== lightlinkPegasus.id && chainId !== lightlinkPhoenix.id)\n    throw new Error(\"Unsupported chain\");\n\n  const explorer =\n    chainId === lightlinkPegasus.id\n      ? lightlinkPegasus.blockExplorers.default.url\n      : lightlinkPhoenix.blockExplorers.default.url;\n  const apiUrl = explorer + \"/api/v2/\";\n\n  const response = await fetch(apiUrl + \"smart-contracts/\" + address);\n  const data = (await response.json()) as Contract;\n\n  return data;\n};\n\nexport const getContractAbi = async (chainId: number, address: string) => {\n  const contract = await getContractInfo(chainId, address);\n  if (!contract.is_verified) {\n    throw new Error(\"Contract is not verified\");\n  }\n\n  return contract.abi;\n};\n","import { createWeb3Name } from \"@web3-name-sdk/core\";\nimport { tldNamehash } from \"@web3-name-sdk/core/utils\";\nimport { createPublicClient, http, type Abi, type Address } from \"viem\";\nimport { lightlinkPhoenix } from \"viem/chains\";\nimport { normalize } from \"viem/ens\";\n\n// \"function resolver(bytes32 node) external view returns (address)\",\nconst ENSRegistryABI: Abi = [\n  {\n    name: \"resolver\",\n    type: \"function\",\n    inputs: [{ type: \"bytes32\", name: \"node\" }],\n    outputs: [{ type: \"address\", name: \"resolver\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\n// \"function addr(bytes32 node) external view returns (address)\",\nconst ENSResolverABI: Abi = [\n  {\n    name: \"addr\",\n    type: \"function\",\n    inputs: [{ type: \"bytes32\", name: \"node\" }],\n    outputs: [{ type: \"address\", name: \"addr\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\nexport const resolveEnsDomain = async (name: string) => {\n  // extract the tld and normalize the domain\n  const tld = name.split(\".\").pop();\n  const normalizedDomain = normalize(name);\n\n  // if its a .ll domain, use the custom resolver\n  if (tld === \"ll\") {\n    return resolveLLDomain(normalizedDomain);\n  }\n\n  // otherwise just use web3-name-sdk to get the address\n  const web3Name = createWeb3Name();\n  const address = await web3Name.getAddress(name);\n  return address as Address;\n};\n\nconst LL_IDENTIFIER =\n  50980310089186268088337308227696701776159000940410532847939554039755637n;\nconst LL_REGISTRY_ADDRESS =\n  \"0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17\" as Address;\n\nexport const resolveLLDomain = async (normalizedDomain: string) => {\n  const nameHash = tldNamehash(normalizedDomain, LL_IDENTIFIER);\n\n  const publicClient = createPublicClient({\n    transport: http(),\n    chain: lightlinkPhoenix,\n  });\n\n  // step 1. get the resolver\n  const resolver = (await publicClient.readContract({\n    address: LL_REGISTRY_ADDRESS,\n    abi: ENSRegistryABI,\n    functionName: \"resolver\",\n    args: [nameHash],\n  })) as Address;\n\n  // step 2. get the address\n  const address = await publicClient.readContract({\n    address: resolver,\n    abi: ENSResolverABI,\n    functionName: \"addr\",\n    args: [nameHash],\n  });\n\n  return address as Address;\n};\n","import type { Abi, Address } from \"viem\";\nimport { getSupportedPublicClient } from \"../chains.js\";\n\nconst TokenABI: Abi = [\n  {\n    name: \"name\",\n    type: \"function\",\n    stateMutability: \"view\",\n    inputs: [],\n    outputs: [{ type: \"string\" }],\n  },\n  {\n    name: \"symbol\",\n    type: \"function\",\n    stateMutability: \"view\",\n    inputs: [],\n    outputs: [{ type: \"string\" }],\n  },\n  {\n    name: \"decimals\",\n    type: \"function\",\n    stateMutability: \"view\",\n    inputs: [],\n    outputs: [{ type: \"uint8\" }],\n  },\n  {\n    name: \"totalSupply\",\n    type: \"function\",\n    stateMutability: \"view\",\n    inputs: [],\n    outputs: [{ type: \"uint256\" }],\n  },\n];\n\nexport interface TokenInfo {\n  name: string;\n  symbol: string;\n  decimals: number;\n  totalSupply: bigint;\n}\n\nexport const fetchTokenName = async (chainId: number, address: Address) => {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  const name = await publicClient.readContract({\n    address,\n    abi: TokenABI,\n    functionName: \"name\",\n  });\n\n  return name as string;\n};\n\nexport const fetchTokenSymbol = async (chainId: number, address: Address) => {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  return (await publicClient.readContract({\n    address,\n    abi: TokenABI,\n    functionName: \"symbol\",\n  })) as string;\n};\n\nexport const fetchTokenDecimals = async (chainId: number, address: Address) => {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  return (await publicClient.readContract({\n    address,\n    abi: TokenABI,\n    functionName: \"decimals\",\n  })) as number;\n};\n\nexport const fetchTokenTotalSupply = async (\n  chainId: number,\n  address: Address\n) => {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  return (await publicClient.readContract({\n    address,\n    abi: TokenABI,\n    functionName: \"totalSupply\",\n  })) as bigint;\n};\n\nexport const fetchTokenInfo = async (chainId: number, address: Address) => {\n  const [name, symbol, decimals, totalSupply] = await Promise.all([\n    fetchTokenName(chainId, address),\n    fetchTokenSymbol(chainId, address),\n    fetchTokenDecimals(chainId, address),\n    fetchTokenTotalSupply(chainId, address),\n  ]);\n\n  return { name, symbol, decimals, totalSupply };\n};\n","import type { Abi, Address } from \"viem\";\nimport { getSupportedPublicClient } from \"../chains.js\";\n\nconst TokenABI: Abi = [\n  {\n    name: \"balanceOf\",\n    inputs: [{ name: \"account\", type: \"address\" }],\n    outputs: [{ name: \"balance\", type: \"uint256\" }],\n    type: \"function\",\n    stateMutability: \"view\",\n  },\n] as const;\n\nexport const fetchBalance = async (\n  chainId: number,\n  token: Address,\n  account: Address\n) => {\n  const publicClient = getSupportedPublicClient(chainId);\n\n  return (await publicClient.readContract({\n    address: token,\n    abi: TokenABI,\n    functionName: \"balanceOf\",\n    args: [account],\n  })) as bigint;\n};\n","import { quoteExactInput, swapExactInput } from \"./elektrik/index.js\";\nexport const elektrik = {\n  quoteExactInput,\n  swapExactInput,\n};\n\nimport { prepareWrapTx, prepareUnwrapTx } from \"./weth/index.js\";\nexport const weth = {\n  prepareWrapTx,\n  prepareUnwrapTx,\n};\n\nexport { search, getContractInfo } from \"./explorer/index.js\";\nexport { resolveEnsDomain, resolveLLDomain } from \"./ens.js\";\nexport {\n  fetchTokenInfo,\n  fetchTokenDecimals,\n  fetchTokenName,\n  fetchTokenSymbol,\n  fetchTokenTotalSupply,\n} from \"./token/info.js\";\nexport { fetchBalance } from \"./token/balance.js\";\nexport {\n  fetchAllowance,\n  prepareApprovalTx,\n  ensureAllowance,\n} from \"./token/approval.js\";\nexport {\n  fetchPermit2Allowance,\n  preparePermit2ApprovalTx,\n  ensurePermit2Allowance,\n} from \"./token/permit2.js\";\n"],"mappings":"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","names":["encodeFunctionData","encodeFunctionData","encodeFunctionData","encodeFunctionData","encodeFunctionData","encodeFunctionData","encodeFunctionData","encodeFunctionData","lightlinkPegasus","lightlinkPhoenix","lightlinkPegasus","lightlinkPhoenix","createPublicClient","http","lightlinkPhoenix","TokenABI","TokenABI"]}